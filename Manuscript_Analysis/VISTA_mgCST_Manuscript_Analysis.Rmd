---
title: "VISTA mgCST Manuscript Analysis"
author: "Amanda Williams"
date: "`r Sys.Date()`"
output: html_document
---


```{G. SWIDSINSKII 1 (mgCST 21) VS G. SWIDSINSKII 3 (mgCST 22)}
# Load libraries
library(devtools) 
library(magrittr)
require(readxl)
library(tidyverse)
library(dplyr)
library(data.table)
library(ggsignif)


# Set seed
set.seed(54321)

# Load files
vog.key <- read.table("VIRGO2_VOGkey.txt", header = T, row.names = NULL, check.names = FALSE, sep = '\t')
samples_w_mgCST <- read.csv("samples_w_mgCSTs.csv")[,c(1,4)]
gene.prod.original <- read.table("6.VIRGO2.geneProduct.txt", sep = "\t", header = TRUE, fill = TRUE, quote = "")
kegg.original <- read.table("7.VIRGO2.kegg.txt", sep = "\t", header = TRUE, fill = TRUE)
samples.clusters <- readRDS(".samples.clusters.updated.vog.RDS")
ngl.gene.counts.list.mgSs.pa.clean <- readRDS("VOG_analysis_updated/vog.list.mgss.pa.RDS")
genes.clusters <- readRDS("vog.clusters.RDS")


### Get VOGs
species <- c()
for (i in names(samples.clusters)){
  if (length(table(samples.clusters[[i]]$sample_cluster)) > 1){
    species <- c(species, i)
  }
}


### Get G. swidsinskii VOGs and count table
gswid <- samples.clusters[["Gardnerella_swidsinkii"]]
swid.vogs <- genes.clusters[["Gardnerella_swidsinkii"]]
swid.vog.counts <- ngl.gene.counts.list.mgSs.pa.clean[["Gardnerella_swidsinkii"]]

# Filter for mgSs 1 and 3
gswid.mgSs <- gswid %>% filter(sample_cluster == "1" | sample_cluster == "3")
swid.vog.counts.t <- t(swid.vog.counts) %>% 
                                          as.data.frame()
swid.vog.counts.t$sampleID <- rownames(swid.vog.counts.t)
swid.vog.counts.t <- swid.vog.counts.t %>% 
                                          relocate(sampleID)
swid.vog.counts.com <- gswid.mgSs %>% 
                                    left_join(swid.vog.counts.t) %>%
                                    arrange(sample_cluster)


## Filter for VOG cluster 3
swid.vog.3 <- swid.vogs %>% filter(vog_cluster == "9")
colnames(swid.vog.3) <- c("VOG", "VOG_Cluster")
swid.vog.3 <- swid.vog.3 %>% left_join(vog.key)


### Get VOGs present in mgSs 1 and 3 + check what is different between groups
vog.list <- swid.vog.3$VOG
matched <- intersect(vog.list, colnames(swid.vog.counts.com))
cols.to.keep <- c(colnames(swid.vog.counts.com)[1:2], matched)
swid.vog.counts.com <- swid.vog.counts.com[ , cols.to.keep]

# Split into metadata and count data
meta <- swid.vog.counts.com[ , 1:2]
vog.counts <- swid.vog.counts.com[ , -(1:2)]
meta[[2]] <- as.factor(meta[[2]])

# Identify samples in each group
mgSs1.samps <- meta[[2]] == "1"
mgSs3.samps <- meta[[2]] == "3"


# Calculate proportion of zeros per gene in each group
zeros.mgSs1 <- colSums(vog.counts[mgSs1.samps, ] == 0, na.rm = TRUE) / sum(mgSs1.samps)
zeros.mgSs3 <- colSums(vog.counts[mgSs3.samps, ] == 0, na.rm = TRUE) / sum(mgSs3.samps)

# Keep genes where one group has >50% zeros and the other has <50%
vogs.to.keep <- names(which(
  (zeros.mgSs1 > 0.5 & zeros.mgSs3 < 0.5) |
    (zeros.mgSs1 < 0.5 & zeros.mgSs3 > 0.5)
))

# Filter original data to keep only selected gene columns
swid.vog.counts.filt <- cbind(meta, vog.counts[ , vogs.to.keep, drop = FALSE])


### Get gene functions
swid.genes.filt <- swid.vog.3 %>% 
                                filter(VOG %in% vogs.to.keep)
swid.function.gp <- swid.genes.filt  %>% left_join(gene.prod.original)
swid.function.kegg <- swid.genes.filt  %>% left_join(kegg.original)
swid.function.caxzy <- swid.genes.filt  %>% left_join(cazy.original)

```


```{G. VAGINALIS mgSs 1 VS mgSs 2 - VISTA mgCST 18}
# Load libraries
library(devtools) 
library(magrittr)
require(readxl)
library(tidyverse)
library(dplyr)
library(data.table)
library(reshape2)


# Set seed
set.seed(54321)

# Load files
vog.key <- read.table("VIRGO2_VOGkey.txt", header = T, row.names = NULL, check.names = FALSE, sep = '\t')
samples_w_mgCST <- read.csv("samples_w_mgCSTs.csv")[ ,c(1,4)]
gene.prod.original <- read.table("6.VIRGO2.geneProduct.txt", sep = "\t", header = TRUE, fill = TRUE, quote = "")
kegg.original <- read.table("7.VIRGO2.kegg.txt", sep = "\t", header = TRUE, fill = TRUE)
samples.clusters <- readRDS("samples.clusters.updated.vog.RDS")
ngl.gene.counts.list.mgSs.pa.clean <- readRDS("vog.list.mgss.pa.RDS")
genes.clusters <- readRDS("vog.clusters.RDS")


### Edit GeneProduct strings
gene.prod.original$GeneProduct <- gsub(" \\(fragment\\)", "", gene.prod.original$GeneProduct, ignore.case = TRUE)


### Get G. vaginalis VOGs and count table
gvag <- samples.clusters[["Gardnerella_vaginalis"]]
vag.vogs <- genes.clusters[["Gardnerella_vaginalis"]]
vag.vog.counts <- ngl.gene.counts.list.mgSs.pa.clean[["Gardnerella_vaginalis"]]

# Filter for mgSs 1 and 2
gvag.mgSs <- gvag %>% filter(sample_cluster == "1" | sample_cluster == "2")
vag.vog.counts.t <- t(vag.vog.counts) %>% 
                                          as.data.frame()
vag.vog.counts.t$sampleID <- rownames(vag.vog.counts.t)
vag.vog.counts.t <- vag.vog.counts.t %>% 
                                        relocate(sampleID)
vag.vog.counts.com <- gvag.mgSs %>% 
                                    left_join(vag.vog.counts.t) %>%
                                    arrange(sample_cluster)


### Get VOGs present in mgSs 1 and 2 + check what is different between groups
colnames(vag.vogs) <- c("VOG", "VOG_Cluster")
vag.vog.all <- vag.vogs %>% left_join(vog.key)

vog.all.list <- vag.vog.all$VOG
matched.all <- intersect(vog.all.list, colnames(vag.vog.counts.com))
cols.to.keep.all <- c(colnames(vag.vog.counts.com)[1:2], matched.all)
vag.vog.counts.com <- vag.vog.counts.com[ , cols.to.keep.all]

# Split into metadata and count data
meta.gvag <- vag.vog.counts.com[ , 1:2]
vog.all.counts <- vag.vog.counts.com[ , -(1:2)]
meta.gvag[[2]] <- as.factor(meta.gvag[[2]])

# Identify samples in each group
gvag.mgSs1.samps <- meta.gvag[[2]] == "1"
gvag.mgSs2.samps <- meta.gvag[[2]] == "2"

## Calculate proportion of zeros per gene in each group
gvag.zeros.mgSs1 <- colSums(vog.all.counts[gvag.mgSs1.samps, ] == 0, na.rm = TRUE) / sum(gvag.mgSs1.samps)
gvag.zeros.mgSs2 <- colSums(vog.all.counts[gvag.mgSs2.samps, ] == 0, na.rm = TRUE) / sum(gvag.mgSs2.samps)

gvag.zeros.mgSs1.df <- as.data.frame(gvag.zeros.mgSs1)
gvag.zeros.mgSs2.df <- as.data.frame(gvag.zeros.mgSs2)
gvag.zeros.df <- merge(gvag.zeros.mgSs1.df, gvag.zeros.mgSs2.df, by = 0, all.x = TRUE, all.y = FALSE)

## Keep genes where one group has >50% zeros and the other has <25%
gvag.vogs.to.keep.2 <- names(which(
  (gvag.zeros.mgSs1 > 0.25 & gvag.zeros.mgSs2 < 0.5)))

gvag.vogs.to.keep.1 <- names(which(
  (gvag.zeros.mgSs1 < 0.5 & gvag.zeros.mgSs2 > 0.25)))

all.gvag.vogs <- names(which(
  (gvag.zeros.mgSs1 < 1.0 & gvag.zeros.mgSs2 > 0)))


# Filter original data to keep only selected gene columns
vag.vog.counts.filt.1 <- cbind(meta.gvag, vog.all.counts[ , gvag.vogs.to.keep.1, drop = FALSE])
vag.vog.counts.filt.2 <- cbind(meta.gvag, vog.all.counts[ , gvag.vogs.to.keep.2, drop = FALSE])
all.vag.vog.counts <- cbind(meta.gvag, vog.all.counts[ , all.gvag.vogs, drop = FALSE])


### Get counts of samples in each mgCST that contain mgSs 1 vs 2 
vag.vog.counts.filt <- vag.vog.counts.filt.1 %>% 
                                                left_join(samples_w_mgCST) %>%
                                                relocate(mgCST, .after = "sampleID")

count.vag <- vag.vog.counts.filt %>%
                                    group_by(mgCST, sample_cluster) %>%               
                                    summarise(count = n(), .groups = "drop") %>%
                                    pivot_wider(names_from = sample_cluster,
                                                values_from = count,
                                                values_fill = 0)

### Get gene functions
vag.genes.filt.1 <- vag.vog.all %>% 
                                filter(VOG %in% gvag.vogs.to.keep.1)
vag.function.gp.1 <- vag.genes.filt.1  %>% left_join(gene.prod.original)
vag.function.kegg.1 <- vag.genes.filt.1  %>% left_join(kegg.original)
vag.function.1 <- vag.function.gp.1  %>% left_join(vag.function.kegg.1)

vag.genes.filt.2 <- vag.vog.all %>% 
                                filter(VOG %in% gvag.vogs.to.keep.2)
vag.function.gp.2 <- vag.genes.filt.2  %>% left_join(gene.prod.original)
vag.function.kegg.2 <- vag.genes.filt.2  %>% left_join(kegg.original)
vag.function.2 <- vag.function.gp.2  %>% left_join(vag.function.kegg.2)


all.vag.gene.func <- vag.vog.all %>% 
                                filter(VOG %in% all.gvag.vogs)
all.vag.function.gp <- all.vag.gene.func  %>% left_join(gene.prod.original)
all.vag.function.kegg <- all.vag.gene.func  %>% left_join(kegg.original)
all.vag.function <- all.vag.function.gp  %>% left_join(all.vag.function.kegg)


### Fucntion in mgSs1 but not in mgSs2, and vice versa
only.mgSs1 <- vag.function.1 %>%
                                  filter(!GeneProduct %in% vag.function.2$GeneProduct) %>%
                                  select(-c(7:10))
only.mgSs2 <- vag.function.2 %>%
                                filter(!GeneProduct %in% vag.function.1$GeneProduct) %>%
                                select(-c(7:10))

mgSs.fun.diff <- bind_rows(data.frame(GeneProduct = only.mgSs1, Source = "Only in mgSs1"),
                           data.frame(GeneProduct = only.mgSs2, Source = "Only in mgSs2"))

## Collapse gene IDs
mgSs.fun.diff.collapsed <- mgSs.fun.diff %>%
                                            group_by(GeneProduct.VOG,
                                                     GeneProduct.VOG_Cluster,
                                                     GeneProduct.Taxonomy,
                                                     GeneProduct.GeneProduct,
                                                     GeneProduct.KEGG,
                                                     Source) %>%
                                            summarise(GeneProduct.Gene = paste(GeneProduct.Gene, collapse = ", "),
                                                      .groups = "drop") %>%
                                            select(GeneProduct.VOG,
                                                   GeneProduct.VOG_Cluster,
                                                   GeneProduct.Gene,
                                                   GeneProduct.Taxonomy,
                                                   GeneProduct.GeneProduct,
                                                   GeneProduct.KEGG,
                                                   Source)


## Check for pullulanase
pullul.genes <- c("MG0684_0111_10", "MG0452_1049_1", "MG2188_0998_1", "MG0080_0097_1", "MG0612_0069_1")
pullul.vogs <- c("VOG0282860", "VOG0282227", "VOG0283238")
pullul.zeros.df <- gvag.zeros.df %>% filter(Row.names %in% pullul.vogs)

## Check if these genes are present by another name
vag.vog.samples <- melt(vag.vog.counts.com)
vag.vog.samples <- vag.vog.samples %>%
                                      filter(value != 0) 

vag.vog.samples <- vag.vog.samples[ , -c(1, 4)]
colnames(vag.vog.samples) <- c("mgSs", "VOG")
vag.vog.samples <- vag.vog.samples %>% distinct()

vog.function <- vag.vog.all %>% left_join(vog.key)
vog.function <- vog.function %>% left_join(vag.vog.samples)
vog.function <- vog.function %>% left_join(gene.prod.original)

```


```{NORMALIZE MT DATA}
# Load libraries
library(devtools) 
library(magrittr)
require(readxl)
library(tidyverse)
library(dplyr)
library(data.table)
library(reshape2)


# Set seed
set.seed(54321)

### The input matrix (exp.mat) should genes as rows and samples as columns
### gene.len is a vector with gene lengths in same order as genes in expression matrix


### Filter out low count genes (30 or reads across all samples)
keep <- rowSums(exp.mat) >= 30
exp.mat <- exp.mat[keep, ]
gene.len <- gene.len[keep]

# Ensure exp.mat is numeric double
exp.mat <- as.matrix(exp.mat)       
storage.mode(exp.mat) <- "double"    
gene.len <- as.numeric(gene.len) 


### Compute TPM
rate <- sweep(exp.mat, 1, gene.len, "/")
rate.sum <- colSums(rate)
TPM <- sweep(rate, 2, rate.sum, "/") * 1e6


```


```{L. CRISPATUS L-LDH AND D-LDH ANALYSIS}
# Load libraries
library(devtools) 
library(magrittr)
require(readxl)
library(tidyverse)
library(dplyr)
library(data.table)
library(reshape2)


# Set seed
set.seed(54321)

# Load files
gene.prod.original <- read.table("6.VIRGO2.geneProduct.txt", sep = "\t", header = TRUE, fill = TRUE, quote = "")
kegg.original <- read.table("7.VIRGO2.kegg.txt", sep = "\t", header = TRUE, fill = TRUE)
virgo.taxa <- read.table("1.VIRGO2.taxon.txt", sep = "\t", header = TRUE, fill = TRUE)
mt.TPM <- read.table("Table_S7.csv", sep = ",", header = TRUE, fill = TRUE)[ ,c(1, 2, 7:ncol(.))]

### mt.TPM needs to be reformatted to have samples as columns and genes as rows. Then, add VIRGO2 taxa as a column

### KEGG IDs for genes of interest
# recA == K03553
# D-lactate dehydrogenase == "K03778,K18347"
# L-lactate dehydrogenase == K00016

### Gene to remove == CIG02738_0012_8 because it has incorrect KEGG ID

### Get only L. cripastus reads
lc.reads <- mt.TPM %>% filter(Taxa == "Lactobacillus_crispatus")

# Remove gene (see above)
lc.reads <- lc.reads %>% 
                        filter(Gene != "CIG02738_0012_8")


### Match KEGG ID to genes for more accurate ID
kegg <- kegg.original[ , c(1:2)]
lc.reads <- lc.reads %>% 
                        left_join(kegg) %>%
                        relocate(KEGG, .after = Gene)

### Filter for genes of interest
lc.reads.filt <- lc.reads %>% 
                            filter(KEGG %in% c("K03553", "K03778,K18347", "K00016"))


### Get only samples with MT data analyzed and filter for mgCSTs needed
lc.mgCSTs <- c("1", "3", "5", "18", "20", "22")
lc.reads.filt <- lc.reads.filt %>% filter(mgCST %in% lc.mgCSTs)
lc.meta.simp <- lc.reads.filt[ , c(1:2)]

lc.samples <- lc.reads.filt$Sample


### Normalize by single copy gene (recA)
# Merge genes of the same function
lc.reads.nr <- lc.reads.filt %>% 
                              group_by(KEGG) %>% 
                              summarise_each(funs(sum)) %>%
                              as.data.frame()

## Remove any sample where the count for K03553 is 0
keep.cols <- sapply(lc.reads.nr[2, -1], function(x) x != 0)
lc.reads.nr <- lc.reads.nr[, c(TRUE, keep.cols)]

# Extract the normalization vector (counts for gene K03553)
norm.vector <- lc.reads.nr[lc.reads.nr[ , 1] == "K03553", -1]

# Divide all counts by the count of K03553 (single copy gene)
lc.reads.norm <- lc.reads.nr
lc.reads.norm[ , -1] <- sweep(lc.reads.norm[, -1], 2, as.numeric(norm.vector), FUN = "/")
lc.reads.norm <- lc.reads.norm[-2 , ]


# Join metadata to count table
lc.reads.t <- lc.reads.norm 
rownames(lc.reads.t) <- lc.reads.t$KEGG
lc.reads.t$KEGG <- NULL
lc.reads.t <- t(lc.reads.t) %>% as.data.frame()

lc.reads.t$Sample <- rownames(lc.reads.t)
lc.reads.t <- lc.reads.t %>% relocate(Sample)
lc.reads.t <- lc.reads.t %>% 
                            left_join(lc.meta.simp) %>%
                            relocate(mgCST, .after = "Sample")


## Format data for plotting
lc.reads.melt <- melt(lc.reads.t)
colnames(lc.reads.melt) <- c("Sample", "mgCST", "Gene", "Abundance")
lc.reads.melt$Group <- ifelse(lc.reads.melt$mgCST %in% c("1", "3", "5"), "1, 3, 5",
                              ifelse(lc.reads.melt$mgCST %in% c("20", "22"), "20, 22",
                                     "18"))
lc.reads.melt$Group <- factor(lc.reads.melt$Group, levels = c("1, 3, 5", "18", "20, 22"))

# Rename KEGG IDs to gene name
lc.reads.melt$Gene <- ifelse(lc.reads.melt$Gene == "K00016", "L-lactate dehydrogenase", "D-lactate dehydrogenase")

## Log-transform data
l.de.df <- lc.reads.melt
l.de.df[ , 4] <- log2(l.de.df[ , 4] + 1)

### Plot genes
Colors <- c("1, 3, 5" = "#FE0308", "18" = "#2C31A0", "20, 22" = "#6B7EC0")

cust.theme <- theme_bw() + theme(text = element_text(size = 11),
                                 legend.position = "none",
                                 strip.text.y = element_text(angle = 0),
                                 strip.text = element_text(size = 11, face = "bold"),
                                 strip.background = element_blank())

ggplot(l.de.df, aes(x = Group, y = Abundance))  + 
      geom_boxplot(aes(fill = Group), outlier.shape = NA) + 
      geom_jitter(color = "black", width = 0.01, size = 0.6, alpha = 0.8) +
      geom_signif(data = sig.df,
                            aes(xmin = xmin, xmax = xmax, annotations = annotations, y_position = y_position),
                            manual = TRUE,
                            textsize = 3.5) + 
      scale_fill_manual(values = Colors, name = "VISTA mgCST") +
      xlab("VISTA mgCST") +
      ylab("Log2[TPM]") +
      facet_wrap(~Gene, nrow = 2, scales = "free_y") + 
      cust.theme +
      theme(strip.background = element_rect(linewidth = 0.2),
            line = element_line(linewidth = 0.2),
            rect = element_rect(linewidth = 0.2))


```


```{SIMILARITY BETWEEN mgCST 18, L. CRISPATUS, AND OTHER GARD mgCSTS}
# Load libraries
library(devtools) 
library(magrittr)
library(tidyverse)
library(dplyr)
library(data.table)
library(MASS)
library(vegan)
library(philentropy)
library(effsize)

## Load files
immune.df <- read.table("Table_S7.csv", sep = ",", header = TRUE, fill = TRUE)[ ,c(1:6)]


### Similarity with immune data ###
colnames(immune.df) <- c("mgCST", "IL1a", "IL1b", "IP10", "MIG")

## Remove extra mgCSTs not needed to analysis/not enough samples
immune.df.corr <- immune.df %>% 
                                filter(mgCST %in% c(1:6, 18:23))

## Code mgCSTs into groups
immune.df.corr$mgCST <- ifelse(immune.df.corr$mgCST %in% 1:6, "Lacto",
                                ifelse(immune.df.corr$mgCST %in% 19:23, "Gard",
                                       "mgCST18"))
immune.df.corr$mgCST <- factor(immune.df.corr$mgCST, levels = c("Lacto", "mgCST18", "Gard"))
immune.df.corr[ , c(2:5)] <- log10(immune.df.corr[ , c(2:5)] + 1)


## Compute group means
group.means <- aggregate(cbind(IL1a, IL1b, IP10, MIG) ~ mgCST, data = immune.df.corr, mean)

## Compute covariance matrix of cytokines
cov.matrix <- cov(immune.df.corr[ , c("IL1a", "IL1b", "IP10", "MIG")])

## Compute Mahalanobis distances
dist.18.Lacto <- mahalanobis(as.numeric(group.means[group.means$mgCST == "mgCST18", -1]),
                             as.numeric(group.means[group.means$mgCST == "Lacto", -1]),
                             cov.matrix)

dist.18.Gard <- mahalanobis(as.numeric(group.means[group.means$mgCST == "mgCST18", -1]),
                            as.numeric(group.means[group.means$mgCST == "Gard", -1]),
                            cov.matrix)

# dist.18.Lacto = 0.03141118 and dist.18.Gard = 0.8377916
# dist.18.Lacto < dist.18.Gard, so mgCST18 is more similar to mgCST1 than mgCST20


### Check with another method
basic.cor <- cor(t(group.means[-1]))

## MANOVA tests
immune.df.corr.1 <- subset(immune.df.corr, mgCST %in% c("mgCST18", "Lacto"))
model.l <- manova(as.matrix(immune.df.corr.1[, 2:5]) ~ mgCST, data = immune.df.corr.1)
summary(model.l, test = "Pillai")

immune.df.corr.2 <- subset(immune.df.corr, mgCST %in% c("mgCST18", "Gard"))
model.g <- manova(as.matrix(immune.df.corr.2[, 2:5]) ~ mgCST, data = immune.df.corr.2)
summary(model.g, test = "Pillai")


## ANOVA tests
# Create ANOVA function
run.anova <- function(data, immune.marker, group.var = "mgCST") {
  formula <- as.formula(paste(immune.marker, "~", group.var))
  
  # Run ANOVA
  result <- aov(formula, data = data)
  
  # Get summary
  summary.result <- summary(result)
  
  # Return summary table with marker name
  return(list(Marker = immune.marker,
              ANOVA = summary.result))
}


# Run ANOVA for each immune marker
immune.markers <- c("IL1a", "IL1b", "IP10", "MIG")

anova.results.l <- lapply(immune.markers, function(marker) {
  run.anova(immune.df.corr.1, marker)
})

anova.results.g <- lapply(immune.markers, function(marker) {
  run.anova(immune.df.corr.2, marker)
})

# Extract p-values from the results
anova.table.l <- do.call(rbind, lapply(anova.results.l, function(res) {
  p.value <- res$ANOVA[[1]][["Pr(>F)"]][1]
  f.value <- res$ANOVA[[1]][["F value"]][1]
  data.frame(Marker = res$Marker, L_P.Value = p.value, L_F.Value = f.value)
}))

anova.table.g <- do.call(rbind, lapply(anova.results.g, function(res) {
  p.value <- res$ANOVA[[1]][["Pr(>F)"]][1]
  f.value <- res$ANOVA[[1]][["F value"]][1]
  data.frame(Marker = res$Marker, G_P.Value = p.value, G_F.Value = f.value)
}))

anova.table <- anova.table.l %>% left_join(anova.table.g)


```


```{FIGURE 2A}
# Load libraries
library(devtools) 
library(magrittr)
require(readxl)
library(tidyverse)
library(dplyr)
library(data.table)
library(reshape2)
library(ggplot2)
library(ggforce)
library(vegan)


# Set seed
set.seed(54321)


# Load files
ngl.abund.clusters.cast.vog <- readRDS("ngl.abund.clusters.cast.vog.RDS")
samples_w_mgCST <- read.csv("samples_w_mgCSTs.csv")[ , c(1,4)]
mgCST.vog.table <- readRDS("mgCST.vog.table.RDS")
VOG <- read.table("VIRGO2_VOGkey.txt", sep = "\t", header = TRUE) %>% filter(Taxonomy != "unknown")
color.key <- read.csv("VIRGO2_TaxaKey.csv", header = TRUE, stringsAsFactors = FALSE)



### Calculate Shannon Diversity index for each mgCST
ngl.abund.clusters.cast.vog<-ngl.abund.clusters.cast.vog/rowSums(ngl.abund.clusters.cast.vog)
ngl.abund.clusters.cast.vog$sampleID <- rownames(ngl.abund.clusters.cast.vog)

# Merge mgCST info with abundance data
ngl.abund.mgCST <- samples_w_mgCST %>%
                                      inner_join(ngl.abund.clusters.cast.vog, by = "sampleID")

# Compute mean Shannon diversity per mgCST
shannon.diversity <- sdi.ngl.abund.mgCST %>%
                                        group_by(mgCST) %>%
                                        summarise(SD = round(sd(Shannon, na.rm = FALSE), 2),
                                                  Shannon = round(mean(Shannon, na.rm = TRUE), 2))

## Everything but Gard species
g.ngl.abund.mgCST <- ngl.abund.mgCST[, !grepl("Gardnerella", colnames(ngl.abund.mgCST))]

# Compute Shannon diversity for each sample
g.ngl.abund.mgCST <- g.ngl.abund.mgCST %>%
                                      mutate(Shannon = diversity(select(., -sampleID, -mgCST), index = "shannon"))

# Create df with SDI for future use
g.SDI <- g.ngl.abund.mgCST[ , c(1, 2, 963)]

# Compute mean Shannon diversity per mgCST
g.shannon.diversity <- g.ngl.abund.mgCST %>%
                                        group_by(mgCST) %>%
                                        summarise(SD = round(sd(Shannon, na.rm = FALSE), 2),
                                                  Shannon = round(mean(Shannon, na.rm = TRUE), 2))

### Get proportions for taxa
ngl.abund.clusters.cast.vog.m <- reshape2::melt(ngl.abund.clusters.cast.vog, id.vars="sampleID", variable.name="mgSs", value.name="proportion")
ngl.abund.clusters.cast.vog.m <- ngl.abund.clusters.cast.vog.m[ngl.abund.clusters.cast.vog.m$proportion > 0, ]
ngl.abund.clusters.cast.vog.m$species <- ifelse(str_count(ngl.abund.clusters.cast.vog.m$mgSs, "_") > 2, 
                                               paste(str_split_fixed(ngl.abund.clusters.cast.vog.m$mgSs, "_", n=4)[,1], 
                                                    str_split_fixed(ngl.abund.clusters.cast.vog.m$mgSs, "_", n=4)[,2], 
                                                    str_split_fixed(ngl.abund.clusters.cast.vog.m$mgSs, "_", n=4)[,3], sep="_"), 
                                               ifelse(str_count(ngl.abund.clusters.cast.vog.m$mgSs, "_") > 1,
                                                     paste(str_split_fixed(ngl.abund.clusters.cast.vog.m$mgSs, "_", n=4)[,1], 
                                                           str_split_fixed(ngl.abund.clusters.cast.vog.m$mgSs, "_", n=4)[,2], sep="_"),
                                                     as.character(ngl.abund.clusters.cast.vog.m$mgSs)))


total.samples <- samples_w_mgCST %>% group_by(mgCST) %>% summarise(tSamples=length(unique(sampleID)))
samples_w_mgCST <- merge(samples_w_mgCST, ngl.abund.clusters.cast.vog.m, all=TRUE)


filtered_list <- lapply(mgCST.vog.table, function(df) {
  melted_df <- reshape2::melt(cbind(VOG=rownames(df), df), id.vars = "VOG", variable.name = "sampleID", value.name = "pa")
  melted_df <- subset(melted_df, pa != 0)
  melted_df$mgCST <- samples_w_mgCST$mgCST[match(melted_df$sampleID, samples_w_mgCST$sampleID)]
  melted_df$Taxonomy <- VOG$Taxonomy[match(melted_df$VOG, VOG$VOG)]
  return(melted_df)
})

mgCST.vog.pa.df <- as.data.frame(rbindlist(filtered_list))


ngl.abund.clusters.cast.vog.m$mgCST <- mgCST.vog.pa.df$mgCST[match(ngl.abund.clusters.cast.vog.m$sampleID, mgCST.vog.pa.df$sampleID)]

# Check how many species present
species.list <- unique(ngl.abund.clusters.cast.vog.m$species)
species.count <- length(unique(ngl.abund.clusters.cast.vog.m$species))

# Filter for Gard mgCSTs and set factor
to.plot <- ngl.abund.clusters.cast.vog.m %>% filter(mgCST %in% c(18:23))
to.plot$mgCST <- factor(to.plot$mgCST, levels = sort(unique(as.numeric(to.plot$mgCST))))

## Handle mgSs and nondescript species names
to.plot <- to.plot[!grepl("_0$", to.plot$mgSs), ]
to.plot$mgSs <- factor(to.plot$mgSs, levels=sort(unique(to.plot$mgSs)))
to.plot$species_toPlot <- ifelse(grepl("Gardnerella_swidsinkii_1$", to.plot$mgSs), as.character(to.plot$mgSs), as.character(to.plot$species))
to.plot$species_toPlot <- gsub("UBA629_sp005465875", "Ca. L. vaginae", to.plot$species_toPlot)
to.plot <- to.plot[!grepl("_sp$", to.plot$species_toPlot), ]
to.plot$species_toPlot <- gsub("uncultured_organism|uncultured_prokaryote|uncultured_bacterium", "Uncultured", to.plot$species_toPlot)
to.plot$species_toPlot <- gsub(".*phage.*", "Phage", to.plot$species_toPlot, ignore.case = TRUE)


## Get taxa colors
color.key$Taxa <- gsub("_", " ", color.key$Taxa)
to.plot$species_toPlot <- gsub("_", " ", to.plot$species_toPlot)

# Change Taxa to Other if not in color scheme
to.plot$species_toPlot <- ifelse(to.plot$species_toPlot %in% color.key$Taxa, 
                                 to.plot$species_toPlot, 
                                 "Other")
taxa.Colors <- setNames(color.key$Color, color.key$Taxa)


### Count number of unique taxa in each mgCST
mgCST.div <- to.plot %>%  
                        group_by(mgCST) %>%  
                        summarise(Count = n_distinct(species))

mgCST.g.div <- to.plot %>%
                          group_by(mgCST) %>%
                          summarise(Gard_Count = n_distinct(species[str_detect(species, "Gardnerella")]))
mgCST.g.div$mgCST <- factor(mgCST.g.div$mgCST)

### Change text in facet strip
to.plot <- to.plot %>% left_join(g.shannon.diversity)
to.plot <- to.plot %>% left_join(mgCST.g.div)
to.plot$Title <- NA
to.plot$Title <- paste0("mgCST", to.plot$mgCST, " (Gardnerella taxa = ", to.plot$Gard_Count, ", SDInon-Gardnerella spp. = ", to.plot$Shannon, ")")

to.plot <- to.plot %>% as.data.frame()


### Plot abundances in each mgCST
## Aggregate all Others into 1 row for each sample
to.plot <- to.plot.name[ , -c(2, 4, 7:9)]

to.plot <- to.plot %>%
                          group_by(across(-proportion)) %>%  
                          summarize(proportion = sum(proportion), .groups = "drop") %>% 
                          ungroup()


## Plot each mgCST
make.mgcst.plot <- function(to.plot, color.key, g.mgcst, Gard.species, cutoff.value) {
  
  # Filter to just the mgCST of interest
  mgCST <- to.plot %>%
                      filter(mgCST == g.mgcst)
  
  # Correct duplicates
  mgCST <- mgCST %>%
    group_by(sampleID) %>%
    do({
      df <- .
      missing <- 1 - sum(df$proportion, na.rm = TRUE)
      if (any(df$species_toPlot == Gard.species)) {
        df$proportion[df$species_toPlot == Gard.species] <- 
          df$proportion[df$species_toPlot == Gard.species] + missing
      } else {
        df <- bind_rows(df, df[1, ] %>%
                          mutate(species_toPlot = Gard.species,
                                 proportion = missing))
      }
      df
    }) %>%
    ungroup()
  
  # Filter out samples where the Gard.species proportion < cutoff.value
  mgCST <- mgCST %>%
                    group_by(sampleID) %>%
                    filter(!(any(species_toPlot == Gard.species & proportion < cutoff.value))) %>%
                    ungroup()
  
  # Filter for dominant species to order samples
  to.plot.filtered <- mgCST %>%
                              filter(species_toPlot == Gard.species) %>%
                              arrange(desc(proportion)) %>%
                              mutate(Order = factor(1:nrow(.), levels = 1:nrow(.))) %>%
                              select(sampleID, Order)
  
  # Order sampleIDs within each mgCST by SDI
  mgCST <- mgCST %>%
                  left_join(to.plot.filtered, by = "sampleID") %>%
                  group_by(Order) %>%
                  arrange(desc(proportion), .by_group = TRUE) %>%
                  mutate(species_toPlot = factor(species_toPlot,
                                                 levels = unique(species_toPlot))) %>%
                  ungroup()
  
  # Order taxa colors by proportion
  taxa.Colors <- setNames(color.key$Color, color.key$Taxa)
  taxa.Colors <- taxa.Colors[unique(mgCST$species_toPlot)]
  
  # Custom theme
  cust.theme <- theme_bw() + theme(strip.text.y = element_text(angle = 0),
                                   strip.text = element_text(size = 11, face = "bold"),
                                   strip.background = element_blank())
  
  # Make plot
  p <- ggplot(mgCST, aes(x = Order, y = proportion, fill = species_toPlot,
                         alpha = ifelse(grepl("Gardnerella", species_toPlot), 1, 0.9))) +
              geom_bar(stat = "identity", position = "fill") +
              scale_fill_manual(values = taxa.Colors, name = "") +
              scale_alpha_identity() +
              ggforce::facet_col(facets = vars(Title),  
                                 scales = "free_x",  
                                 space = "free") +
              xlab("") +
              ylab("Proportion of taxa") +
              guides(fill = guide_legend(byrow = TRUE, override.aes = list(size = 2), nrow = 15)) +
              cust.theme +
              theme(axis.text.x = element_blank(),
                    text = element_text(size = 10),
                    title = ggtext::element_markdown(colour = "black"),
                    legend.text = element_text(face = "italic", size = 8),
                    legend.position = "bottom",
                    strip.background = element_rect(linewidth = 0.2),
                    axis.ticks.x = element_blank(),
                    line = element_line(linewidth = 0.2),
                    legend.key.size = unit(0.01, "cm"),
                    rect = element_rect(linewidth = 0.2),
                    panel.grid = element_blank())
  
  return(p)
}

mgcst.18 <- make.mgcst.plot(to.plot, color.key, g.mgcst = "18", Gard.species = "Gardnerella vaginalis", cutoff.value = 0.10)
mgcst.19 <- make.mgcst.plot(to.plot, color.key, g.mgcst = "19", Gard.species = "Gardnerella vaginalis C", cutoff.value = 0.10)
mgcst.20 <- make.mgcst.plot(to.plot, color.key, g.mgcst = "20", Gard.species = "Gardnerella vaginalis H", cutoff.value = 0.10)
mgcst.21 <- make.mgcst.plot(to.plot, color.key, g.mgcst = "21", Gard.species = "Gardnerella swidsinkii 1", cutoff.value = 0.10)
mgcst.22 <- make.mgcst.plot(to.plot, color.key, g.mgcst = "22", Gard.species = "Gardnerella swidsinkii", cutoff.value = 0.10)
mgcst.23 <- make.mgcst.plot(to.plot, color.key, g.mgcst = "23", Gard.species = "Gardnerella piotii", cutoff.value = 0.10)

## Arrange with shared legend
plots <- list(mgcst.18, mgcst.19, mgcst.20, mgcst.21, mgcst.22, mgcst.23)
plots <- lapply(plots, function(p) p + ylab(NULL))

combined <- ggarrange(plotlist = plots,
                      ncol = 1, nrow = 6,
                      common.legend = TRUE,
                      legend = "bottom")

final.plot <- annotate_figure(combined, 
                              left = text_grob("Relative Abundance", 
                                               rot = 90, size = 10, hjust = -0.35))


```


```{FIGURE 2B}
# Load libraries
library(devtools) 
library(magrittr)
require(readxl)
library(tidyverse)
library(dplyr)
library(data.table)
library(reshape2)
library(pheatmap)


# Set seed
set.seed(54321)


# Load files
ngl.abund.clusters.cast.vog <- readRDS("ngl.abund.clusters.cast.vog.RDS")
samples_w_mgCST <- read.csv("samples_w_mgCSTs.csv")[ , c(1,4)]
mt.TPM <- read.table("Table_S7.csv", sep = ",", header = TRUE, fill = TRUE)[ ,c(1, 2, 7:ncol(.))]


### Get sums of each species within each sample
mt.TPM.spp <- mt.TPM %>% 
                        group_by(Taxa) %>% 
                        summarise_each(funs(sum)) %>%
                        as.data.frame()


### Get samples used for MT and format MG data (merge mgSs)
ngl.abund.clusters.cast.vog <- ngl.abund.clusters.cast.vog/rowSums(ngl.abund.clusters.cast.vog)
ngl.abund.clusters.cast.vog$sampleID <- rownames(ngl.abund.clusters.cast.vog)

# Merge mgCST info with abundance data
ngl.abund.mgCST <- samples_w_mgCST %>%
                                      inner_join(ngl.abund.clusters.cast.vog, by = "sampleID")
ngl.abund.mgCST <- MTMG.map %>% left_join(ngl.abund.mgCST, by = c("MG" = "sampleID"))
ngl.abund.mgCST <- ngl.abund.mgCST[ngl.abund.mgCST$MT %in% samples, ]

ngl.abund.mgCST <- ngl.abund.mgCST %>%
                                      pivot_longer(cols = 5:1038, names_to = "species", values_to = "count") %>%
                                      mutate(species = sub("_[0-9]{1,2}$", "", species)) %>%
                                      group_by(across(1:4), species) %>%
                                      summarise(count = sum(count, na.rm = TRUE), .groups = "drop") %>%
                                      pivot_wider(names_from = species, values_from = count)

colnames(ngl.abund.mgCST) <- gsub("_", " ", colnames(ngl.abund.mgCST))


### Replace expression counts with 0 if not present in MG data
species <- rownames(mt.TPM.spp)
matched <- intersect(species, colnames(ngl.abund.mgCST))
cols.to.keep <- c(colnames(ngl.abund.mgCST)[1:4], matched)
abund.filt <- ngl.abund.mgCST[ , cols.to.keep]

abund.filt.simp <- abund.filt[ , -c(2:4)]

# Loop through each row (i.e., species) in abund.filt.simp
mt.TPM.filt <- mt.TPM.spp

for (i in 2:ncol(abund.filt.simp)) {  
  species.name <- colnames(abund.filt.simp)[i]
  
  # For samples where that species has a 0 count
  zero.samples <- abund.filt.simp$MT[abund.filt.simp[[species.name]] == 0]
  
  # Set those to 0 in most.exp (if they exist)
  common.samples <- intersect(zero.samples, colnames(mt.TPM.filt))
  if (length(common.samples) > 0 && species.name %in% rownames(mt.TPM.filt)) {
    mt.TPM.filt[species.name, common.samples] <- 0
  }
}


### Filter for most expressed species and log transform
most.exp <- mt.TPM.filt %>%
                            mutate(Sum = rowSums(., na.rm = TRUE)) %>%
                            arrange(desc(Sum)) %>%
                            head(90) %>%
                            dplyr::select(-Sum)
most.exp.spp <- log2(most.exp + 1)


### Remove extra mgCSTs not needed to analysis/not enough samples
most.exp.spp <- most.exp.spp %>%
                                group_by(mgCST) %>%
                                filter(n() > 4) %>%
                                ungroup()
most.exp.spp <- most.exp.spp %>% 
                      filter(!(mgCST %in% c(8:17, 24:25)))
most.exp.spp$mgCST <- factor(most.exp.spp$mgCST, levels = c(1:25))

# Create column annotations and set order of samples
col.annot <- most.exp.spp %>%
                              ungroup() %>%
                              select(MT, mgCST) %>%
                              arrange(mgCST) %>%
                              as.data.frame()
rownames(col.annot) <- col.annot$MT
col.annot$MT <- NULL

# Update most.exp to match the order of columns in col.annot
most.exp <- most.exp[ , rownames(col.annot)]

# Compute row clustering using Ward's linkage
row.dist <- dist(as.matrix(most.exp), method = "manhattan")
row.clust <- hclust(row.dist, method = "ward.D")

## Set plot characteristics
colfunc <- colorRampPalette(c("khaki", "limegreen", "darkslategray1", "mediumblue", "magenta", "red"))

mgCST.Colors <- c("1" = "#FE0308", "3" = "#F07084", "5" = "#F0BCCC",
                  "18" = "#2C31A0", "20" = "#444DAC", "22" = "#6B7EC0")

# Spp names
t.most.exp <- t(most.exp) %>% as.data.frame()
t.most.exp$MT <- rownames(t.most.exp)

italic_row_labels <- lapply(names(t.most.exp), function(label) {
  if(grepl("^f ", label)){
    return(label)
  }
  if(grepl("^o ", label)){
    return(label)
  }
  if(grepl("^v ", label)){
    return(label)
  }
  if(grepl("^c ", label)){
    return(label)
  }
  if(grepl("^p ", label)){
    return(label)
  }
  if(grepl("Other", label)){
    return(label)
  }
  else{
    return(bquote(italic(.(label))))
  }
})


## Set column gaps for each mgCST
mgCST.groups <- as.numeric(col.annot$mgCST)
col.gaps <- which(diff(mgCST.groups) != 0)

# Create a new matrix with thin spacer columns
most.exp.spaced <- most.exp
gap.cols <- col.gaps  # Indices where gaps should appear
for (gap in rev(gap.cols)) {
  most.exp.spaced <- cbind(most.exp.spaced[, 1:gap], 
                           rep(NA, nrow(most.exp.spaced)),  # Spacer column
                           most.exp.spaced[ , (gap + 1):ncol(most.exp.spaced)])
}

# Plot the modified heatmap
heatmap <- pheatmap(as.matrix(most.exp),
                     color = colfunc(50),
                     cluster_rows = row.clust,
                     cluster_cols = FALSE,
                     show_colnames = FALSE,
                     show_rownames = TRUE,
                     labels_row = as.expression(italic_row_labels),
                     annotation_legend = TRUE,
                     fontsize = 10,
                     annotation_col = col.annot,
                     annotation_colors = list(mgCST = mgCST.Colors),
                     fontsize_row = 8,
                     angle_col = 0,
                     cellwidth = 3.5,
                     cellheight = 7.6,
                     border_color = NA)


```

